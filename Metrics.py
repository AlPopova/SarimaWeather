# -*- coding: utf-8 -*-
"""Rasha1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PqYjpsEqkHN1FUlQTP-viXlu9y8rzFno
"""

# Commented out IPython magic to ensure Python compatibility.
#from google.colab import drive
#drive.mount('/content/drive')
# %cp /content/drive/MyDrive/my_data.csv /content/

# Import numpy, pandas for data manipulation
import numpy as np
import pandas as pd
# Import matplotlib, seaborn for visualization
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)
# Import the data
weather_data = pd.read_csv(r'C:\Users\Александр\Downloads\Telegram Desktop\my_data.csv', sep=';', decimal=',')
import datetime
date=weather_data.apply(lambda x: datetime.date(int(x['year']), int(x['month']),int(x['day'])),axis=1)

date = pd.to_datetime(date)

# 1st plot: Daily Temperature  from 2005 to 2010
weather_data = weather_data.drop(columns=['year', 'month', 'day'])

weather_data.insert(0, 'Date', date)
temp_df = weather_data[['Date','T']]
temp_df["T"] = temp_df["T"].astype(str).astype(float)
temp_df.head(10)
temp_df.shape
mask = (temp_df['Date'] >= '2005-01-01') & (temp_df['Date'] <= '2010-12-31')
temp_df = temp_df.loc[mask]

# Reset the index 
temp_df.set_index("Date", inplace=True)
# Inspect first 5 rows and last 5 rows of the data
#3from IPython.display import display
#display(temp_df.head(5))
#display(temp_df.tail(5)) 

temp_df.describe()
# Plot the daily temperature change 
plt.figure(figsize=(16,10), dpi=100)
plt.plot(temp_df.index, temp_df, color='tab:blue')
plt.gca().set(title="Daily Temperature  from 2005 to 2010", xlabel='Date', ylabel="Degree (in Celsius)")
###plt.show()
temp_df_mean = temp_df.T.rolling(window=30).mean()
#temp_df_mean.plot(figsize=(20,15))

# 2nd plot: Additive Decomposition
from statsmodels.tsa.seasonal import seasonal_decompose

# Additive Decomposition
result_add = seasonal_decompose(temp_df, model='additive', extrapolate_trend='freq', freq=365)

# Plot
plt.rcParams.update({'figure.figsize': (10,10)})
result_add.plot().suptitle('Additive Decomposition', fontsize=22)
###plt.show()
# Shift the current temperature to the next day. 
predicted_df = temp_df["T"].to_frame().shift(1).rename(columns = {"T": "T_pred" })
actual_df = temp_df["T"].to_frame().rename(columns = {"T": "T_actual" })

# Concatenate the actual and predicted temperature
one_step_df = pd.concat([actual_df,predicted_df],axis=1)

# Select from the second row, because there is no prediction for today due to shifting.
one_step_df = one_step_df[1:]
one_step_df.head(10)

from sklearn.metrics import mean_squared_error as MSE
from math import sqrt

# Calculate the RMSE
#temp_pred_err = MSE(one_step_df.T_actual, one_step_df.T_pred, squared=False)
#print("The RMSE(seasonal_decompose) is",temp_pred_err)

import itertools

# Define the p, d and q parameters to take any value between 0 and 2
p = d = q = range(0, 2)

# Generate all different combinations of p, q and q triplets
pdq = list(itertools.product(p, d, q))

# Generate all different combinations of seasonal p, q and q triplets
seasonal_pdq = [(x[0], x[1], x[2], 12) for x in list(itertools.product(p, d, q))]

import warnings
warnings.filterwarnings("ignore") # specify to ignore warning messages

# Import the statsmodels library for using SARIMAX model
import statsmodels.api as sm
"""min=200000
for param in pdq:
    for param_seasonal in seasonal_pdq:
        try:
            mod = sm.tsa.statespace.SARIMAX(one_step_df.T_actual,
                                            order=param,
                                            seasonal_order=param_seasonal,
                                            enforce_stationarity=False,
                                            enforce_invertibility=False)

            results = mod.fit()
            if min>results.aic:
                min=results.aic
                pmin=param
                psmin=param_seasonal
            print('SARIMA{}x{}12 - AIC:{}'.format(param, param_seasonal, results.aic))
        except:
            continue
print('BestSARIMA{}x{}12 - AIC:{}'.format(pmin, psmin, min))"""        




# Fit the SARIMAX model using optimal parameters
mod = sm.tsa.statespace.SARIMAX(one_step_df.T_actual,
                                order=(1, 0, 1),
                                seasonal_order=(0, 1, 1, 12),
                                enforce_stationarity=False,
                                enforce_invertibility=False)
results = mod.fit()
results.plot_diagnostics(figsize=(15, 12))
###plt.show()
pred = results.get_prediction(start=pd.to_datetime('2007-05-19'), dynamic=False)
pred_ci = pred.conf_int()
ax = one_step_df.T_actual['2005':].plot(label='observed')
pred.predicted_mean.plot(ax=ax, label='Forecast')

ax.fill_between(pred_ci.index,
                pred_ci.iloc[:, 0],
                pred_ci.iloc[:, 1], color='k', alpha=.2)

ax.set_xlabel('Date')
ax.set_ylabel('Temperature (in Celsius)')
plt.ylim([-31,35])
plt.legend()
plt.show()
mape=sum(abs(one_step_df[pd.to_datetime('2007-05-19'):].T_actual-pred.predicted_mean))/len(pred.predicted_mean)
rmse=np.sqrt(sum((one_step_df[pd.to_datetime('2007-05-19'):].T_actual-pred.predicted_mean)**2)/(len(pred.predicted_mean)-1))


